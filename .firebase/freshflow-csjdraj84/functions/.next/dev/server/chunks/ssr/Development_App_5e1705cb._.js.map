{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["file:///Users/dhanarajjayapalan/Development/App/app/actions/order.ts"],"sourcesContent":["\"use server\";\n\nimport fs from 'fs';\nimport path from 'path';\nimport { GroceryItem, prisma } from '@/lib/items';\nimport { revalidatePath } from 'next/cache';\n\nconst ORDER_FILE = path.join(process.cwd(), 'data/current-order.json');\n\n// Type for the transformed order returned by getOrder\nexport interface OrderWithGroceryItems {\n    id: number;\n    totalItems: number;\n    createdAt: Date;\n    updatedAt: Date;\n    items: GroceryItem[];\n}\n\nexport async function saveOrder(items: GroceryItem[], orderId?: number) {\n    try {\n        // 1. Save to JSON (Legacy support)\n        fs.writeFileSync(ORDER_FILE, JSON.stringify(items, null, 2));\n\n        // 2. Save to Database\n        if (items.length > 0) {\n            if (orderId) {\n                // UPDATE existing order\n                await prisma.$transaction(async (tx) => {\n                    // Update total items\n                    await tx.order.update({\n                        where: { id: orderId },\n                        data: { totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0) }\n                    });\n\n                    // Delete existing items\n                    await tx.orderItem.deleteMany({\n                        where: { orderId: orderId }\n                    });\n\n                    // Re-create items\n                    for (const item of items) {\n                        await tx.orderItem.create({\n                            data: {\n                                orderId: orderId,\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }\n                        });\n                    }\n                });\n            } else {\n                // CREATE new order\n                await prisma.order.create({\n                    data: {\n                        totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0),\n                        items: {\n                            create: items.map(item => ({\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }))\n                        }\n                    }\n                });\n            }\n        }\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to save order:\", e);\n        return { success: false, error: 'Failed to save' };\n    }\n}\n\nexport async function deleteOrder(orderId: number) {\n    try {\n        // Delete OrderItems first, then Order (to satisfy foreign key constraint)\n        await prisma.$transaction(async (tx) => {\n            await tx.orderItem.deleteMany({\n                where: { orderId: orderId }\n            });\n            await tx.order.delete({\n                where: { id: orderId }\n            });\n        });\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to delete order:\", e);\n        return { success: false, error: 'Failed to delete' };\n    }\n}\n\nexport async function getOrders() {\n    try {\n        const orders = await prisma.order.findMany({\n            orderBy: { createdAt: 'desc' },\n            include: {\n                items: {\n                    include: {\n                        item: true\n                    }\n                }\n            }\n        });\n\n        // Map Prisma result to Order interface (handling nulls and field mapping)\n        return orders.map(order => ({\n            ...order,\n            items: order.items.map(oi => ({\n                id: oi.id,\n                orderId: oi.orderId,\n                itemId: oi.itemId,\n                itemName: oi.itemName,\n                quantity: oi.quantity,\n                item: oi.item ? {\n                    name: oi.item.name,\n                    id: oi.item.id,\n                    tamilName: oi.item.tamilName || undefined,\n                    imageUrl: oi.item.imagePath || undefined,\n                    createdAt: oi.item.createdAt\n                } : undefined\n            }))\n        }));\n    } catch (e) {\n        console.error(\"Failed to fetch orders:\", e);\n        return [];\n    }\n}\n\nexport async function getOrder(id: number): Promise<OrderWithGroceryItems | null> {\n    try {\n        const order = await prisma.order.findUnique({\n            where: { id },\n            include: { items: { include: { item: true } } }\n        });\n\n        if (!order) return null;\n\n        return {\n            id: order.id,\n            totalItems: order.totalItems,\n            createdAt: order.createdAt,\n            updatedAt: order.updatedAt,\n            items: order.items.map((oi) => ({\n                id: oi.item.id,\n                name: oi.item.name,\n                tamilName: oi.item.tamilName || undefined,\n                imageUrl: oi.item.imagePath || undefined,\n                quantity: oi.quantity\n            }))\n        };\n    } catch (e) {\n        console.error(\"Failed to fetch order:\", e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;MAkBsB,wBAAA,WAAA,GAAA,IAAA,qQAAA,EAAA,8CAAA,0PAAA,EAAA,KAAA,GAAA,gQAAA,EAAA,6CAAA"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///Users/dhanarajjayapalan/Development/App/app/actions/order.ts"],"sourcesContent":["\"use server\";\n\nimport fs from 'fs';\nimport path from 'path';\nimport { GroceryItem, prisma } from '@/lib/items';\nimport { revalidatePath } from 'next/cache';\n\nconst ORDER_FILE = path.join(process.cwd(), 'data/current-order.json');\n\n// Type for the transformed order returned by getOrder\nexport interface OrderWithGroceryItems {\n    id: number;\n    totalItems: number;\n    createdAt: Date;\n    updatedAt: Date;\n    items: GroceryItem[];\n}\n\nexport async function saveOrder(items: GroceryItem[], orderId?: number) {\n    try {\n        // 1. Save to JSON (Legacy support)\n        fs.writeFileSync(ORDER_FILE, JSON.stringify(items, null, 2));\n\n        // 2. Save to Database\n        if (items.length > 0) {\n            if (orderId) {\n                // UPDATE existing order\n                await prisma.$transaction(async (tx) => {\n                    // Update total items\n                    await tx.order.update({\n                        where: { id: orderId },\n                        data: { totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0) }\n                    });\n\n                    // Delete existing items\n                    await tx.orderItem.deleteMany({\n                        where: { orderId: orderId }\n                    });\n\n                    // Re-create items\n                    for (const item of items) {\n                        await tx.orderItem.create({\n                            data: {\n                                orderId: orderId,\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }\n                        });\n                    }\n                });\n            } else {\n                // CREATE new order\n                await prisma.order.create({\n                    data: {\n                        totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0),\n                        items: {\n                            create: items.map(item => ({\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }))\n                        }\n                    }\n                });\n            }\n        }\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to save order:\", e);\n        return { success: false, error: 'Failed to save' };\n    }\n}\n\nexport async function deleteOrder(orderId: number) {\n    try {\n        // Delete OrderItems first, then Order (to satisfy foreign key constraint)\n        await prisma.$transaction(async (tx) => {\n            await tx.orderItem.deleteMany({\n                where: { orderId: orderId }\n            });\n            await tx.order.delete({\n                where: { id: orderId }\n            });\n        });\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to delete order:\", e);\n        return { success: false, error: 'Failed to delete' };\n    }\n}\n\nexport async function getOrders() {\n    try {\n        const orders = await prisma.order.findMany({\n            orderBy: { createdAt: 'desc' },\n            include: {\n                items: {\n                    include: {\n                        item: true\n                    }\n                }\n            }\n        });\n\n        // Map Prisma result to Order interface (handling nulls and field mapping)\n        return orders.map(order => ({\n            ...order,\n            items: order.items.map(oi => ({\n                id: oi.id,\n                orderId: oi.orderId,\n                itemId: oi.itemId,\n                itemName: oi.itemName,\n                quantity: oi.quantity,\n                item: oi.item ? {\n                    name: oi.item.name,\n                    id: oi.item.id,\n                    tamilName: oi.item.tamilName || undefined,\n                    imageUrl: oi.item.imagePath || undefined,\n                    createdAt: oi.item.createdAt\n                } : undefined\n            }))\n        }));\n    } catch (e) {\n        console.error(\"Failed to fetch orders:\", e);\n        return [];\n    }\n}\n\nexport async function getOrder(id: number): Promise<OrderWithGroceryItems | null> {\n    try {\n        const order = await prisma.order.findUnique({\n            where: { id },\n            include: { items: { include: { item: true } } }\n        });\n\n        if (!order) return null;\n\n        return {\n            id: order.id,\n            totalItems: order.totalItems,\n            createdAt: order.createdAt,\n            updatedAt: order.updatedAt,\n            items: order.items.map((oi) => ({\n                id: oi.item.id,\n                name: oi.item.name,\n                tamilName: oi.item.tamilName || undefined,\n                imageUrl: oi.item.imagePath || undefined,\n                quantity: oi.quantity\n            }))\n        };\n    } catch (e) {\n        console.error(\"Failed to fetch order:\", e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;MA4EsB,wBAAA,WAAA,GAAA,IAAA,qQAAA,EAAA,8CAAA,0PAAA,EAAA,KAAA,GAAA,gQAAA,EAAA,+CAAA"}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///Users/dhanarajjayapalan/Development/App/app/actions/order.ts"],"sourcesContent":["\"use server\";\n\nimport fs from 'fs';\nimport path from 'path';\nimport { GroceryItem, prisma } from '@/lib/items';\nimport { revalidatePath } from 'next/cache';\n\nconst ORDER_FILE = path.join(process.cwd(), 'data/current-order.json');\n\n// Type for the transformed order returned by getOrder\nexport interface OrderWithGroceryItems {\n    id: number;\n    totalItems: number;\n    createdAt: Date;\n    updatedAt: Date;\n    items: GroceryItem[];\n}\n\nexport async function saveOrder(items: GroceryItem[], orderId?: number) {\n    try {\n        // 1. Save to JSON (Legacy support)\n        fs.writeFileSync(ORDER_FILE, JSON.stringify(items, null, 2));\n\n        // 2. Save to Database\n        if (items.length > 0) {\n            if (orderId) {\n                // UPDATE existing order\n                await prisma.$transaction(async (tx) => {\n                    // Update total items\n                    await tx.order.update({\n                        where: { id: orderId },\n                        data: { totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0) }\n                    });\n\n                    // Delete existing items\n                    await tx.orderItem.deleteMany({\n                        where: { orderId: orderId }\n                    });\n\n                    // Re-create items\n                    for (const item of items) {\n                        await tx.orderItem.create({\n                            data: {\n                                orderId: orderId,\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }\n                        });\n                    }\n                });\n            } else {\n                // CREATE new order\n                await prisma.order.create({\n                    data: {\n                        totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0),\n                        items: {\n                            create: items.map(item => ({\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }))\n                        }\n                    }\n                });\n            }\n        }\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to save order:\", e);\n        return { success: false, error: 'Failed to save' };\n    }\n}\n\nexport async function deleteOrder(orderId: number) {\n    try {\n        // Delete OrderItems first, then Order (to satisfy foreign key constraint)\n        await prisma.$transaction(async (tx) => {\n            await tx.orderItem.deleteMany({\n                where: { orderId: orderId }\n            });\n            await tx.order.delete({\n                where: { id: orderId }\n            });\n        });\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to delete order:\", e);\n        return { success: false, error: 'Failed to delete' };\n    }\n}\n\nexport async function getOrders() {\n    try {\n        const orders = await prisma.order.findMany({\n            orderBy: { createdAt: 'desc' },\n            include: {\n                items: {\n                    include: {\n                        item: true\n                    }\n                }\n            }\n        });\n\n        // Map Prisma result to Order interface (handling nulls and field mapping)\n        return orders.map(order => ({\n            ...order,\n            items: order.items.map(oi => ({\n                id: oi.id,\n                orderId: oi.orderId,\n                itemId: oi.itemId,\n                itemName: oi.itemName,\n                quantity: oi.quantity,\n                item: oi.item ? {\n                    name: oi.item.name,\n                    id: oi.item.id,\n                    tamilName: oi.item.tamilName || undefined,\n                    imageUrl: oi.item.imagePath || undefined,\n                    createdAt: oi.item.createdAt\n                } : undefined\n            }))\n        }));\n    } catch (e) {\n        console.error(\"Failed to fetch orders:\", e);\n        return [];\n    }\n}\n\nexport async function getOrder(id: number): Promise<OrderWithGroceryItems | null> {\n    try {\n        const order = await prisma.order.findUnique({\n            where: { id },\n            include: { items: { include: { item: true } } }\n        });\n\n        if (!order) return null;\n\n        return {\n            id: order.id,\n            totalItems: order.totalItems,\n            createdAt: order.createdAt,\n            updatedAt: order.updatedAt,\n            items: order.items.map((oi) => ({\n                id: oi.item.id,\n                name: oi.item.name,\n                tamilName: oi.item.tamilName || undefined,\n                imageUrl: oi.item.imagePath || undefined,\n                quantity: oi.quantity\n            }))\n        };\n    } catch (e) {\n        console.error(\"Failed to fetch order:\", e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;MAgGsB,wBAAA,WAAA,GAAA,IAAA,qQAAA,EAAA,8CAAA,0PAAA,EAAA,KAAA,GAAA,gQAAA,EAAA,6CAAA"}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///Users/dhanarajjayapalan/Development/App/app/actions/order.ts"],"sourcesContent":["\"use server\";\n\nimport fs from 'fs';\nimport path from 'path';\nimport { GroceryItem, prisma } from '@/lib/items';\nimport { revalidatePath } from 'next/cache';\n\nconst ORDER_FILE = path.join(process.cwd(), 'data/current-order.json');\n\n// Type for the transformed order returned by getOrder\nexport interface OrderWithGroceryItems {\n    id: number;\n    totalItems: number;\n    createdAt: Date;\n    updatedAt: Date;\n    items: GroceryItem[];\n}\n\nexport async function saveOrder(items: GroceryItem[], orderId?: number) {\n    try {\n        // 1. Save to JSON (Legacy support)\n        fs.writeFileSync(ORDER_FILE, JSON.stringify(items, null, 2));\n\n        // 2. Save to Database\n        if (items.length > 0) {\n            if (orderId) {\n                // UPDATE existing order\n                await prisma.$transaction(async (tx) => {\n                    // Update total items\n                    await tx.order.update({\n                        where: { id: orderId },\n                        data: { totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0) }\n                    });\n\n                    // Delete existing items\n                    await tx.orderItem.deleteMany({\n                        where: { orderId: orderId }\n                    });\n\n                    // Re-create items\n                    for (const item of items) {\n                        await tx.orderItem.create({\n                            data: {\n                                orderId: orderId,\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }\n                        });\n                    }\n                });\n            } else {\n                // CREATE new order\n                await prisma.order.create({\n                    data: {\n                        totalItems: items.reduce((sum, i) => sum + (i.quantity || 1), 0),\n                        items: {\n                            create: items.map(item => ({\n                                itemId: item.id!,\n                                itemName: item.name,\n                                quantity: item.quantity || 1\n                            }))\n                        }\n                    }\n                });\n            }\n        }\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to save order:\", e);\n        return { success: false, error: 'Failed to save' };\n    }\n}\n\nexport async function deleteOrder(orderId: number) {\n    try {\n        // Delete OrderItems first, then Order (to satisfy foreign key constraint)\n        await prisma.$transaction(async (tx) => {\n            await tx.orderItem.deleteMany({\n                where: { orderId: orderId }\n            });\n            await tx.order.delete({\n                where: { id: orderId }\n            });\n        });\n\n        revalidatePath('/');\n        return { success: true };\n    } catch (e) {\n        console.error(\"Failed to delete order:\", e);\n        return { success: false, error: 'Failed to delete' };\n    }\n}\n\nexport async function getOrders() {\n    try {\n        const orders = await prisma.order.findMany({\n            orderBy: { createdAt: 'desc' },\n            include: {\n                items: {\n                    include: {\n                        item: true\n                    }\n                }\n            }\n        });\n\n        // Map Prisma result to Order interface (handling nulls and field mapping)\n        return orders.map(order => ({\n            ...order,\n            items: order.items.map(oi => ({\n                id: oi.id,\n                orderId: oi.orderId,\n                itemId: oi.itemId,\n                itemName: oi.itemName,\n                quantity: oi.quantity,\n                item: oi.item ? {\n                    name: oi.item.name,\n                    id: oi.item.id,\n                    tamilName: oi.item.tamilName || undefined,\n                    imageUrl: oi.item.imagePath || undefined,\n                    createdAt: oi.item.createdAt\n                } : undefined\n            }))\n        }));\n    } catch (e) {\n        console.error(\"Failed to fetch orders:\", e);\n        return [];\n    }\n}\n\nexport async function getOrder(id: number): Promise<OrderWithGroceryItems | null> {\n    try {\n        const order = await prisma.order.findUnique({\n            where: { id },\n            include: { items: { include: { item: true } } }\n        });\n\n        if (!order) return null;\n\n        return {\n            id: order.id,\n            totalItems: order.totalItems,\n            createdAt: order.createdAt,\n            updatedAt: order.updatedAt,\n            items: order.items.map((oi) => ({\n                id: oi.item.id,\n                name: oi.item.name,\n                tamilName: oi.item.tamilName || undefined,\n                imageUrl: oi.item.imagePath || undefined,\n                quantity: oi.quantity\n            }))\n        };\n    } catch (e) {\n        console.error(\"Failed to fetch order:\", e);\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;MAqIsB,wBAAA,WAAA,GAAA,IAAA,qQAAA,EAAA,8CAAA,0PAAA,EAAA,KAAA,GAAA,gQAAA,EAAA,4CAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/dhanarajjayapalan/Development/App/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0]}}]
}